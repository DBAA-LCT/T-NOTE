# T-Note 内存优化方案

## 问题分析

通过代码审查，发现以下可能导致内存占用高的问题：

### 1. Quill 编辑器实例管理
**问题：**
- 每个 Editor 组件都创建一个 Quill 实例
- 分屏模式下同时存在多个 Quill 实例
- Quill 实例占用内存较大（富文本编辑器的通病）

**影响：**
- 每个 Quill 实例约占用 5-10MB 内存
- 多个 Tab 打开时内存累积

### 2. 事件监听器未清理
**问题：**
- Editor 组件中有多个 useEffect 添加事件监听
- 部分监听器可能未正确清理

**影响：**
- 内存泄漏
- 事件监听器累积

### 3. 大量 DOM 操作
**问题：**
- 书签和待办的 DOM 同步操作频繁
- 每次内容变化都会遍历所有书签和待办元素

**影响：**
- 性能下降
- 内存占用增加

### 4. 自动保存定时器
**问题：**
- 每次内容变化都创建新的定时器
- 可能存在定时器未清理的情况

**影响：**
- 定时器累积
- 内存泄漏

---

## 优化方案

### 优化 1: 优化 Quill 编辑器实例管理

#### 方案 A: 延迟加载编辑器
只在 Tab 激活时才创建 Quill 实例，非激活状态使用轻量级预览。

#### 方案 B: 限制同时打开的 Tab 数量
设置最大 Tab 数量（如 5 个），超过时自动关闭最早的 Tab。

#### 方案 C: 编辑器实例复用
使用单例模式，多个页面共享同一个编辑器实例。

**推荐：方案 B + 优化现有代码**

---

### 优化 2: 改进事件监听器管理

#### 问题代码示例：
```typescript
// Editor.tsx - 可能存在的问题
useEffect(() => {
  const handleClick = (e: MouseEvent) => {
    // ...
  };
  
  const editor = editorContainerRef.current;
  if (editor) {
    editor.addEventListener('click', handleClick);
    // 清理函数可能在某些情况下不执行
    return () => {
      editor.removeEventListener('click', handleClick);
    };
  }
}, [page, todos]); // 依赖项变化频繁
```

#### 优化方案：
1. 减少 useEffect 的依赖项
2. 使用 useCallback 缓存事件处理函数
3. 确保所有事件监听器都有清理函数

---

### 优化 3: 减少 DOM 操作频率

#### 问题代码：
```typescript
// 每次 todos 变化都遍历所有 DOM 元素
useEffect(() => {
  const todoElements = editor.querySelectorAll('.ql-todo');
  todoElements.forEach((element) => {
    // 更新每个元素
  });
}, [todos, page?.id]);
```

#### 优化方案：
1. 使用防抖（debounce）减少更新频率
2. 只更新变化的元素，而不是全部
3. 使用 MutationObserver 监听 DOM 变化

---

### 优化 4: 优化自动保存机制

#### 当前实现：
```typescript
useEffect(() => {
  if (!note || !currentFilePath || !hasUnsavedChanges) return;

  const autoSaveTimer = setTimeout(async () => {
    // 保存逻辑
  }, 3000);

  return () => clearTimeout(autoSaveTimer);
}, [note, currentFilePath, hasUnsavedChanges]);
```

#### 问题：
- note 对象变化频繁，导致定时器频繁创建和销毁

#### 优化方案：
使用 useRef 存储定时器，避免频繁创建。

---

### 优化 5: 减少不必要的重渲染

#### 使用 React.memo 优化组件
```typescript
export default React.memo(Editor, (prevProps, nextProps) => {
  return prevProps.page?.id === nextProps.page?.id &&
         prevProps.page?.content === nextProps.page?.content;
});
```

#### 使用 useMemo 缓存计算结果
```typescript
const sortedTodos = useMemo(() => {
  return [...filteredTodos].sort((a, b) => {
    // 排序逻辑
  });
}, [filteredTodos, sortBy]);
```

---

## 具体实现

### 1. 限制 Tab 数量

```typescript
// App.tsx
const MAX_TABS = 5;

const handleSelectPage = (pageId: string) => {
  setCurrentPageId(pageId);
  
  if (!leftTabs.includes(pageId) && !rightTabs.includes(pageId)) {
    setLeftTabs(prev => {
      const newTabs = [...prev, pageId];
      // 如果超过最大数量，移除最早的 Tab
      if (newTabs.length > MAX_TABS) {
        return newTabs.slice(1);
      }
      return newTabs;
    });
    setActiveLeftTab(pageId);
    setActiveSide('left');
  } else if (leftTabs.includes(pageId)) {
    setActiveLeftTab(pageId);
    setActiveSide('left');
  } else if (rightTabs.includes(pageId)) {
    setActiveRightTab(pageId);
    setActiveSide('right');
  }
};
```

### 2. 优化自动保存

```typescript
// App.tsx
const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null);

useEffect(() => {
  if (!note || !currentFilePath || !hasUnsavedChanges) return;

  // 清除之前的定时器
  if (autoSaveTimerRef.current) {
    clearTimeout(autoSaveTimerRef.current);
  }

  // 创建新的定时器
  autoSaveTimerRef.current = setTimeout(async () => {
    try {
      await window.electronAPI.saveNoteToPath(currentFilePath, JSON.stringify(note, null, 2));
      setHasUnsavedChanges(false);
      console.log('自动保存成功');
    } catch (error) {
      console.error('自动保存失败:', error);
      message.error('自动保存失败');
    }
  }, 3000);

  return () => {
    if (autoSaveTimerRef.current) {
      clearTimeout(autoSaveTimerRef.current);
    }
  };
}, [hasUnsavedChanges]); // 只依赖 hasUnsavedChanges
```

### 3. 优化 DOM 同步（使用防抖）

```typescript
// Editor.tsx
import { debounce } from 'lodash'; // 或自己实现

const syncTodoStatus = useCallback(
  debounce((todos: TodoItem[], pageId: string) => {
    const editor = editorContainerRef.current;
    if (!editor) return;

    const todoElements = editor.querySelectorAll('.ql-todo');
    todoElements.forEach((element) => {
      const todoId = element.getAttribute('data-todo-id');
      if (todoId) {
        const todo = todos.find(t => t.id === todoId);
        if (todo) {
          if (todo.completed) {
            element.setAttribute('data-completed', 'true');
          } else {
            element.removeAttribute('data-completed');
          }
          element.setAttribute('title', `待办: ${todo.title}${todo.completed ? ' (已完成)' : ''}`);
        }
      }
    });
  }, 300), // 300ms 防抖
  []
);

useEffect(() => {
  if (!todos || todos.length === 0 || !page) return;
  syncTodoStatus(todos, page.id);
}, [todos, page?.id, syncTodoStatus]);
```

### 4. 使用 React.memo 优化组件

```typescript
// Editor.tsx
const Editor = React.memo(
  forwardRef<EditorRef, EditorProps>(({ page, onUpdatePage, todos, onAddTodo, onUpdateTodo, onDeleteTodo, onJumpToPage }, ref) => {
    // 组件代码
  }),
  (prevProps, nextProps) => {
    // 自定义比较逻辑
    return (
      prevProps.page?.id === nextProps.page?.id &&
      prevProps.page?.content === nextProps.page?.content &&
      prevProps.page?.title === nextProps.page?.title &&
      prevProps.todos?.length === nextProps.todos?.length
    );
  }
);
```

### 5. 清理未使用的状态和变量

```typescript
// 移除不必要的状态
// 使用 useMemo 缓存计算结果
// 使用 useCallback 缓存函数
```

---

## 性能监控

### 添加性能监控代码

```typescript
// App.tsx
useEffect(() => {
  if (process.env.NODE_ENV === 'development') {
    const logMemory = () => {
      if (performance.memory) {
        console.log('Memory Usage:', {
          usedJSHeapSize: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + ' MB',
          totalJSHeapSize: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + ' MB',
          jsHeapSizeLimit: (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2) + ' MB'
        });
      }
    };

    const interval = setInterval(logMemory, 10000); // 每10秒记录一次
    return () => clearInterval(interval);
  }
}, []);
```

---

## 优化优先级

### 高优先级（立即实施）
1. ✅ 优化自动保存机制（使用 useRef）
2. ✅ 限制 Tab 数量（最多 5 个）
3. ✅ 添加性能监控代码

### 中优先级（短期实施）
4. 使用 React.memo 优化组件
5. 优化 DOM 同步（使用防抖）
6. 减少 useEffect 依赖项

### 低优先级（长期优化）
7. 编辑器实例复用
8. 虚拟滚动（如果页面列表很长）
9. 代码分割和懒加载

---

## 预期效果

实施上述优化后，预期可以：
- 减少 30-50% 的内存占用
- 提升 20-30% 的响应速度
- 减少内存泄漏风险
- 改善长时间使用的稳定性

---

## 测试建议

1. 使用 Chrome DevTools 的 Memory Profiler 监控内存
2. 测试长时间使用（1小时以上）的内存变化
3. 测试多个 Tab 打开时的内存占用
4. 测试大文件（>1MB）的加载和编辑性能
5. 使用 React DevTools Profiler 分析渲染性能

---

## 下一步

1. 先实施高优先级优化
2. 测试优化效果
3. 根据测试结果调整优化方案
4. 逐步实施中低优先级优化
